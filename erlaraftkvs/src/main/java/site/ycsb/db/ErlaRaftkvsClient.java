package site.ycsb.db;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import site.ycsb.*;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import com.ericsson.otp.erlang.*;

import com.fasterxml.jackson.databind.ObjectMapper;


/**
 * YCSB client for the Raftkvs spec generated by Erla+.
 */
public class ErlaRaftkvsClient extends DB {
  private static OtpNode node = null;

  /** A mapping of thread-IDs to mailboxes. **/
  private static final Map<Long, OtpMbox> THREAD_MBOXES = new ConcurrentHashMap<>();

  private static final String COOKIE = "cookie";

  /** Count the number of times initialized to teardown on the last. */
  private static final AtomicInteger INIT_COUNT = new AtomicInteger(0);

  private static String hostName;
  private static OtpErlangList raftNodes;

  private static final String CLIENT_NODE_NAME = "client1";
  private static final String CLIENT_MODULE_NAME = "raft_erla_client";
  private static final String CLIENT_PROC_NAME = "raftkvs_client_%s";
  private static final int CLIENT_PROC_ID_OFFSET = 666;


  @Override
  public void init() {
    int currThreadIndex = INIT_COUNT.incrementAndGet();
    synchronized (ErlaRaftkvsClient.class) {
      if (node == null) {
        try {
          /*
            Create and register self
          */
          node = new OtpNode("YCSB_server", COOKIE);
          /*
            Establish connection to remote client node
          */
          if (!node.ping(CLIENT_NODE_NAME, 10000)) {
            throw new RuntimeException("Remote client node is not running");
          } else {
            System.out.println("Remote client node is running!");
          }

          hostName = (String) this.getProperties().get("erlang_host_name");
          raftNodes = new OtpErlangList(new OtpErlangAtom("node1@" + hostName)); // todo
        } catch (IOException e) {
          throw new RuntimeException("Error during initialization: " + e);
        }
      }
      /*
        Create mailbox for current thread
      */
      OtpMbox currentMbox = node.createMbox("thread_" + currThreadIndex);
      System.out.println("Put mailbox for thread with index " + currThreadIndex);
      THREAD_MBOXES.put(Thread.currentThread().getId(), currentMbox);
      System.out.println(THREAD_MBOXES);

      // start remote client processes via rpc
      try {
        OtpSelf self = new OtpSelf("client", COOKIE);
        OtpPeer other  = new OtpPeer(CLIENT_NODE_NAME);
        OtpConnection connection = null;
        try {
          connection = self.connect(other);

          OtpErlangList args = new OtpErlangList(new OtpErlangObject[] {
              new OtpErlangInt(CLIENT_PROC_ID_OFFSET + currThreadIndex),
              new OtpErlangAtom(String.format(CLIENT_PROC_NAME, currentMbox.getName())),
              raftNodes
          });

          connection.sendRPC(CLIENT_MODULE_NAME, "start_link", args);
          OtpErlangObject received = connection.receiveRPC();
          System.out.println(received.toString());
        } catch (IOException | OtpAuthException | OtpErlangExit e) {
          throw new RuntimeException(e);
        } finally {
          if (connection != null) {
            connection.close();
          }
        }
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }
  }


  @Override
  public void cleanup() {
    if (INIT_COUNT.decrementAndGet() == 0) {
      THREAD_MBOXES.clear();
      THREAD_MBOXES.values().forEach(OtpMbox::close);
      node.close();
    }
  }

  /**
   * Read a record from the database. Each field/value pair from the result will be stored in a HashMap.
   *
   * @param table  The name of the table
   * @param key    The record key of the record to read.
   * @param fields The list of fields to read, or null for all of them
   * @param result A HashMap of field/value pairs for the result
   * @return The result of the operation.
   */
  @Override
  public Status read(String table, String key, Set<String> fields, Map<String, ByteIterator> result) {
    OtpMbox currentMbox = getMailboxForCurrentThread();
    String keyVal = createKey(table, key);
    OtpErlangTuple msg = new OtpErlangTuple(
        new OtpErlangObject[]{
            new OtpErlangAtom("get"),
            new OtpErlangString(keyVal),
            new OtpErlangInt(1), // leader ID, todo
            currentMbox.self()
        }
    );

    sendMsg(currentMbox, msg);

    OtpMsg response;
    try {
      response = currentMbox.receiveMsg(3000);
    } catch (OtpErlangExit | InterruptedException e) {
      throw new RuntimeException(e);
    }

    OtpErlangObject responsePayload = null;
    if (response != null) {
      try {
        responsePayload =  response.getMsg();
      } catch (OtpErlangDecodeException e) {
        throw new RuntimeException(e);
      }
    }
    if (responsePayload != null) {
      System.out.println("Response: " + responsePayload);

      if (responsePayload.getClass() != OtpErlangTuple.class) {
        throw new IllegalStateException("Received unexpected response type " + responsePayload.getClass());
      }
      OtpErlangTuple responseTuple = (OtpErlangTuple) responsePayload;

      if (responseTuple.arity() != 3) {
        throw new IllegalStateException("Received unexpected number of terms in response tuple. " +
            "Received: " + responseTuple.arity() + ", Expected: 3");
      }

      OtpErlangAtom isSuccess = (OtpErlangAtom) responseTuple.elementAt(0); // has the leader responded?
      OtpErlangAtom isFound = (OtpErlangAtom) responseTuple.elementAt(1); // was the key present in the KVS?
      OtpErlangString value = (OtpErlangString) responseTuple.elementAt(2); // the value linked to the key

      if (!isSuccess.booleanValue()) {
        throw new IllegalStateException("Read request failed. Leader has changed.");
      }

      if (!isFound.booleanValue()) {
        return Status.NOT_FOUND;
      }

      // Convert JSON value to Map
      ObjectMapper mapper = new ObjectMapper();
      HashMap<String, String> values;
      try {
        values = mapper.readValue(value.stringValue(), new TypeReference<HashMap<String, String>>() {});
      } catch (JsonProcessingException e) {
        throw new RuntimeException(e);
      }

      for (Map.Entry<String, String> entry : values.entrySet()) {
        result.put(entry.getKey(), new StringByteIterator(entry.getValue()));
      }

      return Status.OK;
    } else {
      return Status.ERROR;
    }
  }

  /**
   * Perform a range scan for a set of records in the database. Each field/value pair from the result will be stored
   * in a HashMap.
   *
   * @param table       The name of the table
   * @param startkey    The record key of the first record to read.
   * @param recordcount The number of records to read
   * @param fields      The list of fields to read, or null for all of them
   * @param result      A Vector of HashMaps, where each HashMap is a set field/value pairs for one record
   * @return The result of the operation.
   */
  @Override
  public Status scan(String table, String startkey, int recordcount,
      Set<String> fields, Vector<HashMap<String, ByteIterator>> result) {
    return Status.NOT_IMPLEMENTED; // not supported
  }

  /**
   * Update a record in the database. Any field/value pairs in the specified values HashMap will be written into the
   * record with the specified record key, overwriting any existing values with the same field name.
   *
   * @param table  The name of the table
   * @param key    The record key of the record to write.
   * @param values A HashMap of field/value pairs to update in the record
   * @return The result of the operation.
   */
  @Override
  public Status update(String table, String key, Map<String, ByteIterator> values) {
    return insert(table, key, values); // todo: maybe send a read request first?
  }

  /**
   * Insert a record in the database. Any field/value pairs in the specified values HashMap will be written into the
   * record with the specified record key.
   *
   * @param table  The name of the table
   * @param key    The record key of the record to insert.
   * @param values A HashMap of field/value pairs to insert in the record
   * @return The result of the operation.
   */
  @Override
  public Status insert(String table, String key, Map<String, ByteIterator> values) {
    Map<String, String> strValues = values.entrySet()
        .stream()
        .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().toString()));
    String content;
    try {
      content = new ObjectMapper().writeValueAsString(strValues);
    } catch (JsonProcessingException e) {
      throw new RuntimeException(e);
    }
    OtpMbox currentMbox = getMailboxForCurrentThread();
    String keyVal = createKey(table, key);
    OtpErlangTuple msg = new OtpErlangTuple(
        new OtpErlangObject[]{
            new OtpErlangAtom("put"),
            new OtpErlangTuple(new OtpErlangObject[]{new OtpErlangString(keyVal), new OtpErlangString(content)}),
            new OtpErlangInt(1),
            currentMbox.self()
        }
    );

    sendMsg(currentMbox, msg);

    OtpErlangObject responsePayload  = receiveMsg(currentMbox);

    // todo: do something with responsePayload> (e.g. get current leader in case insert failed)

    return Status.OK;
  }

  private OtpErlangObject receiveMsg(OtpMbox currentMbox) {
    OtpMsg response;
    try {
      response = currentMbox.receiveMsg();
    } catch (OtpErlangExit e) {
      throw new RuntimeException(e);
    }

    if (response != null) {
      try {
        OtpErlangObject responsePayload =  response.getMsg();
        System.out.println(responsePayload.toString());
        return responsePayload;
      } catch (OtpErlangDecodeException e) {
        throw new RuntimeException(e);
      }
    } else {
      throw new IllegalStateException("Error in message reception");
    }
  }

  /**
   * Delete a record from the database.
   *
   * @param table The name of the table
   * @param key   The record key of the record to delete.
   * @return The result of the operation.
   */
  @Override
  public Status delete(String table, String key) {
    return null;
  }

  private String createKey(String table, String key) {
    return table + "/" + key;
  }

  private void sendMsg(OtpMbox currentMbox, OtpErlangTuple msg) {
    currentMbox.send(String.format(CLIENT_PROC_NAME, currentMbox.getName()), CLIENT_NODE_NAME, msg);
  }

  private OtpMbox getMailboxForCurrentThread() {
    long id = Thread.currentThread().getId();
    OtpMbox res = THREAD_MBOXES.get(id);
    if (res == null) {
      throw new RuntimeException("Mailbox for thread id \"" + id + "\" not found");
    }
    return res;
  }
}