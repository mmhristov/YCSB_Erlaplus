package site.ycsb.db;

import com.fasterxml.jackson.core.JsonProcessingException;
import site.ycsb.ByteIterator;
import site.ycsb.DB;
import site.ycsb.DBException;
import site.ycsb.Status;

import java.util.*;
import java.util.stream.Collectors;

import com.ericsson.otp.erlang.*;

import com.fasterxml.jackson.databind.ObjectMapper;


/**
 * YCSB client for the Raftkvs spec generated by Erla+.
 */
public class ErlaRaftkvsClient extends DB {
  private final OtpNode client;
  private final OtpMbox mbox;

  private static final List<String> RAFT_NODES = Arrays.asList("proc_1", "proc_2", "proc_3");
  private static final List<String> CLIENTS = Arrays.asList("client1");

  private static final List<Integer> CLIENT_PROC_NAMES = Arrays.asList(666);

  private static final int REQ_INDEX = 0;

  public ErlaRaftkvsClient() {
    try {
      /*
        Create and register self
       */
      this.client = new OtpNode("YCSB_server", "cookie");
      this.mbox = this.client.createMbox("YCSB_server_mailbox");

      /*
        Establish connection to remote client
       */
      if (!client.ping(CLIENTS.get(0), 10000)) {
        throw new RuntimeException("Remote client is not running");
      }
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  @Override
  public void init() throws DBException {
    super.init();
  }

  /**
   * Read a record from the database. Each field/value pair from the result will be stored in a HashMap.
   *
   * @param table  The name of the table
   * @param key    The record key of the record to read.
   * @param fields The list of fields to read, or null for all of them
   * @param result A HashMap of field/value pairs for the result
   * @return The result of the operation.
   */
  @Override
  public Status read(String table, String key, Set<String> fields, Map<String, ByteIterator> result) {
    String keyVal = createKey(table, key);

    int currentClientId = 0;

    //[#{key_type => "Put", key_key => "a", key_value => "Value1"}, #{key_type => "Get", key_key => "a"}],
    // #{key_mtype => "ClientGetRequest", key_mcmd => #{key_idx => State1#state_client.var_reqId, key_type => "Get",
    //  key_key => maps:get(key_key, State1#state_client.var_req)}, key_msource => State1#state_client.procvar_ID})
    OtpErlangMap payload = new OtpErlangMap(
        // keys
        new OtpErlangObject[]{
            new OtpErlangAtom("key_mtype"),
            new OtpErlangAtom("key_mcmd"),
            new OtpErlangAtom("key_msource")
        },
        // values
        new OtpErlangObject[]{
            new OtpErlangString("ClientGetRequest"),
            new OtpErlangMap(
                // keys
                new OtpErlangObject[]{
                    new OtpErlangAtom("key_idx"),
                    new OtpErlangAtom("key_type"),
                    new OtpErlangAtom("key_key")},
                // values
                new OtpErlangObject[]{
                    new OtpErlangInt(REQ_INDEX),
                    new OtpErlangString("Get"),
                    new OtpErlangString(keyVal)}
            ),
            new OtpErlangInt(CLIENT_PROC_NAMES.get(currentClientId))
        }
    );

    OtpErlangTuple msg = new OtpErlangTuple(
        new OtpErlangObject[]{new OtpErlangAtom("redirect"), payload, new OtpErlangInt(1), mbox.self()});


    mbox.send("raftkvs_client", CLIENTS.get(0), msg);

    OtpMsg response;
    try {
      response = mbox.receiveMsg();
    } catch (OtpErlangExit e) {
      throw new RuntimeException(e);
    }

    if (response != null) {
      try {
        OtpErlangObject responsePayload =  response.getMsg();
        System.out.println(responsePayload.toString());
      } catch (OtpErlangDecodeException e) {
        throw new RuntimeException(e);
      }
    }
    return Status.OK;
  }

  /**
   * Perform a range scan for a set of records in the database. Each field/value pair from the result will be stored
   * in a HashMap.
   *
   * @param table       The name of the table
   * @param startkey    The record key of the first record to read.
   * @param recordcount The number of records to read
   * @param fields      The list of fields to read, or null for all of them
   * @param result      A Vector of HashMaps, where each HashMap is a set field/value pairs for one record
   * @return The result of the operation.
   */
  @Override
  public Status scan(String table, String startkey, int recordcount,
      Set<String> fields, Vector<HashMap<String, ByteIterator>> result) {
    return Status.NOT_IMPLEMENTED; // not supported
  }

  /**
   * Update a record in the database. Any field/value pairs in the specified values HashMap will be written into the
   * record with the specified record key, overwriting any existing values with the same field name.
   *
   * @param table  The name of the table
   * @param key    The record key of the record to write.
   * @param values A HashMap of field/value pairs to update in the record
   * @return The result of the operation.
   */
  @Override
  public Status update(String table, String key, Map<String, ByteIterator> values) {
    return null;
  }

  /**
   * Insert a record in the database. Any field/value pairs in the specified values HashMap will be written into the
   * record with the specified record key.
   *
   * @param table  The name of the table
   * @param key    The record key of the record to insert.
   * @param values A HashMap of field/value pairs to insert in the record
   * @return The result of the operation.
   */
  @Override
  public Status insert(String table, String key, Map<String, ByteIterator> values) {
    // #{key_mtype => "ClientPutRequest", key_mcmd => #{key_idx => State1#state_client.var_reqId, key_type => "Put",
    //  key_key => maps:get(key_key, State1#state_client.var_req),
    //  key_value => maps:get(key_value, State1#state_client.var_req)}, key_msource => State1#state_client.procvar_ID})
    String keyVal = createKey(table, key);
    Map<String, String> strValues = values.entrySet()
        .stream()
        .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().toString()));
    String content = "";
    try {
      content = new ObjectMapper().writeValueAsString(strValues);
    } catch (JsonProcessingException e) {
      throw new RuntimeException(e);
    }

    OtpErlangTuple msg = new OtpErlangTuple(
        new OtpErlangObject[]{
            new OtpErlangAtom("put"),
            new OtpErlangTuple(new OtpErlangObject[]{new OtpErlangString(keyVal), new OtpErlangString(content)}),
            new OtpErlangInt(1),
            mbox.self()
        }
    );

    mbox.send("raftkvs_client", CLIENTS.get(0), msg);

    OtpMsg response;
    try {
      response = mbox.receiveMsg();
    } catch (OtpErlangExit e) {
      throw new RuntimeException(e);
    }

    if (response != null) {
      try {
        OtpErlangObject responsePayload =  response.getMsg();
        System.out.println(responsePayload.toString());
      } catch (OtpErlangDecodeException e) {
        throw new RuntimeException(e);
      }
    }

    return Status.OK;
  }

  /**
   * Delete a record from the database.
   *
   * @param table The name of the table
   * @param key   The record key of the record to delete.
   * @return The result of the operation.
   */
  @Override
  public Status delete(String table, String key) {
    return null;
  }

  private String createKey(String table, String key) {
    return table + "/" + key;
  }
}