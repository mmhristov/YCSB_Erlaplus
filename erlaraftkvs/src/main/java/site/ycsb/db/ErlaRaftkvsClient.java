package site.ycsb.db;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import site.ycsb.*;

import java.util.*;
import java.util.stream.Collectors;

import com.ericsson.otp.erlang.*;

import com.fasterxml.jackson.databind.ObjectMapper;


/**
 * YCSB client for the Raftkvs spec generated by Erla+.
 */
public class ErlaRaftkvsClient extends DB {
  private final OtpNode client;
  private final OtpMbox mbox;

  private static final List<String> RAFT_NODES = Arrays.asList("proc_1", "proc_2", "proc_3");
  private static final List<String> CLIENTS = Arrays.asList("client1");

  private static final List<Integer> CLIENT_PROC_NAMES = Arrays.asList(666);

  private static final int REQ_INDEX = 0;

  public ErlaRaftkvsClient() {
    try {
      /*
        Create and register self
       */
      this.client = new OtpNode("YCSB_server", "cookie");
      this.mbox = this.client.createMbox("YCSB_server_mailbox");

      /*
        Establish connection to remote client
       */
      if (!client.ping(CLIENTS.get(0), 10000)) {
        throw new RuntimeException("Remote client is not running");
      }
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  @Override
  public void init() throws DBException {
    super.init();
  }

  /**
   * Read a record from the database. Each field/value pair from the result will be stored in a HashMap.
   *
   * @param table  The name of the table
   * @param key    The record key of the record to read.
   * @param fields The list of fields to read, or null for all of them
   * @param result A HashMap of field/value pairs for the result
   * @return The result of the operation.
   */
  @Override
  public Status read(String table, String key, Set<String> fields, Map<String, ByteIterator> result) {
    String keyVal = createKey(table, key);

    int currentClientId = 0;

    OtpErlangTuple msg = new OtpErlangTuple(
        new OtpErlangObject[]{
            new OtpErlangAtom("get"),
            new OtpErlangString(keyVal),
            new OtpErlangInt(1),
            mbox.self()
        }
    );

    mbox.send("raftkvs_client", CLIENTS.get(0), msg);

    OtpMsg response;
    try {
      response = mbox.receiveMsg(3000);
    } catch (OtpErlangExit | InterruptedException e) {
      throw new RuntimeException(e);
    }

    OtpErlangObject responsePayload = null;
    if (response != null) {
      try {
        responsePayload =  response.getMsg();
      } catch (OtpErlangDecodeException e) {
        throw new RuntimeException(e);
      }
    }
    if (responsePayload != null) {
      System.out.println("Response: " + responsePayload);

      if (responsePayload.getClass() != OtpErlangTuple.class) {
        throw new IllegalStateException("Received unexpected response type " + responsePayload.getClass());
      }
      OtpErlangTuple responseTuple = (OtpErlangTuple) responsePayload;

      if (responseTuple.arity() != 3) {
        throw new IllegalStateException("Received unexpected number of terms in response tuple. " +
            "Received: " + responseTuple.arity() + ", Expected: 3");
      }

      OtpErlangAtom isSuccess = (OtpErlangAtom) responseTuple.elementAt(0); // has the leader responded?
      OtpErlangAtom isFound = (OtpErlangAtom) responseTuple.elementAt(1); // was the key present in the KVS?
      OtpErlangString value = (OtpErlangString) responseTuple.elementAt(2); // the value linked to the key

      if (!isSuccess.booleanValue()) {
        throw new IllegalStateException("Read request failed. Leader has changed.");
      }

      if (!isFound.booleanValue()) {
        return Status.NOT_FOUND;
      }

      // Convert JSON value to Map
      ObjectMapper mapper = new ObjectMapper();
      HashMap<String, String> values;
      try {
        values = mapper.readValue(value.stringValue(), new TypeReference<HashMap<String, String>>() {});
      } catch (JsonProcessingException e) {
        throw new RuntimeException(e);
      }

      for (Map.Entry<String, String> entry : values.entrySet()) {
        result.put(entry.getKey(), new StringByteIterator(entry.getValue()));
      }

      return Status.OK;
    } else {
      return Status.ERROR;
    }
  }

  /**
   * Perform a range scan for a set of records in the database. Each field/value pair from the result will be stored
   * in a HashMap.
   *
   * @param table       The name of the table
   * @param startkey    The record key of the first record to read.
   * @param recordcount The number of records to read
   * @param fields      The list of fields to read, or null for all of them
   * @param result      A Vector of HashMaps, where each HashMap is a set field/value pairs for one record
   * @return The result of the operation.
   */
  @Override
  public Status scan(String table, String startkey, int recordcount,
      Set<String> fields, Vector<HashMap<String, ByteIterator>> result) {
    return Status.NOT_IMPLEMENTED; // not supported
  }

  /**
   * Update a record in the database. Any field/value pairs in the specified values HashMap will be written into the
   * record with the specified record key, overwriting any existing values with the same field name.
   *
   * @param table  The name of the table
   * @param key    The record key of the record to write.
   * @param values A HashMap of field/value pairs to update in the record
   * @return The result of the operation.
   */
  @Override
  public Status update(String table, String key, Map<String, ByteIterator> values) {
    return null;
  }

  /**
   * Insert a record in the database. Any field/value pairs in the specified values HashMap will be written into the
   * record with the specified record key.
   *
   * @param table  The name of the table
   * @param key    The record key of the record to insert.
   * @param values A HashMap of field/value pairs to insert in the record
   * @return The result of the operation.
   */
  @Override
  public Status insert(String table, String key, Map<String, ByteIterator> values) {
    // #{key_mtype => "ClientPutRequest", key_mcmd => #{key_idx => State1#state_client.var_reqId, key_type => "Put",
    //  key_key => maps:get(key_key, State1#state_client.var_req),
    //  key_value => maps:get(key_value, State1#state_client.var_req)}, key_msource => State1#state_client.procvar_ID})
    String keyVal = createKey(table, key);
    Map<String, String> strValues = values.entrySet()
        .stream()
        .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().toString()));
    String content;
    try {
      content = new ObjectMapper().writeValueAsString(strValues);
    } catch (JsonProcessingException e) {
      throw new RuntimeException(e);
    }

    OtpErlangTuple msg = new OtpErlangTuple(
        new OtpErlangObject[]{
            new OtpErlangAtom("put"),
            new OtpErlangTuple(new OtpErlangObject[]{new OtpErlangString(keyVal), new OtpErlangString(content)}),
            new OtpErlangInt(1),
            mbox.self()
        }
    );

    mbox.send("raftkvs_client", CLIENTS.get(0), msg);

    OtpMsg response;
    try {
      response = mbox.receiveMsg();
    } catch (OtpErlangExit e) {
      throw new RuntimeException(e);
    }

    if (response != null) {
      try {
        OtpErlangObject responsePayload =  response.getMsg();
        System.out.println(responsePayload.toString());
      } catch (OtpErlangDecodeException e) {
        throw new RuntimeException(e);
      }
    }

    return Status.OK;
  }

  /**
   * Delete a record from the database.
   *
   * @param table The name of the table
   * @param key   The record key of the record to delete.
   * @return The result of the operation.
   */
  @Override
  public Status delete(String table, String key) {
    return null;
  }

  private String createKey(String table, String key) {
    return table + "/" + key;
  }
}